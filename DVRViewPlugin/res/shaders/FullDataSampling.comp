#version 430

layout(local_size_x = 1, local_size_y = 32, local_size_z = 1) in;

// SSBO for per‑ray pixel indices.
layout(std430, binding = 0) buffer IndicesBuffer {
    int indices[];
};

// SSBO for per‑ray starting output offset in amount of samples that come before it (not accounting the dimension of those samples).
layout(std430, binding = 1) buffer StartIndicesBuffer {
    int startIndices[];
};

// SSBO for output samples.
layout(std430, binding = 2) buffer OutputBuffer {
    float data[];
};

// Sampler uniforms.
uniform sampler2D frontFaces;  // Contains the front face positions (in [0,1], scaled by dataDimensions)
uniform sampler2D backFaces;   // Contains the back face positions (in [0,1], scaled by dataDimensions)
uniform sampler3D volumeData;  // Holds the volume atlas data, where each brick gives 4 channels

// Uniforms for volume atlas sampling.
uniform vec3 dataDimensions;   // The volume dataset dimensions
uniform vec3 invDataDimensions; // 1.0 / dataDimensions
uniform vec3 atlasLayout;       // Number of bricks in x, y, and z (packed into one vec3)

uniform vec3 invAtlasLayout;    // Precomputed reciprocal of atlasLayout so we can avoid divisions: 1.0 / atlasLayout.
uniform int voxelDimensions;    // Number of components per voxel (can be > 4)
uniform vec2 invFaceTexSize;    // Pre-divided (1.0 / face texture width, 1.0 / face texture height)

// Other parameters.
uniform float stepSize;         // Ray marching step size
uniform int numIndices;         // Number of rays to process
uniform int bricksNeeded;       // (voxelDimensions+3)/4: number of bricks needed per voxel

void main()
{
    // Use the y component of gl_GlobalInvocationID as the ray ID (one ray per workgroup row)
    uint rayID = gl_GlobalInvocationID.x;
    if (rayID >= uint(numIndices))
        return;
    
    // Use the y-dimension of the workgroup to partition the samples along the ray.
    // Each thread along y will process every N-th sample (where N == gl_WorkGroupSize.y).
    uint sampleThread = gl_GlobalInvocationID.y; // range: 0 .. 31 (if local_size_y==32)

    // Retrieve the pixel index for this ray.
    int pixelIndex = indices[rayID];

    // Compute normalized texture coordinates using the precomputed inverse face texture size.
    // These coordinates are used to sample the front and back face textures.
    float x = fract(float(pixelIndex) * invFaceTexSize.x);
    float y = floor(float(pixelIndex) * invFaceTexSize.x) * invFaceTexSize.y;
    vec2 normTexCoords = vec2(x, y);

    // Sample the front and back face textures.
    // The textures contain values in the [0,1] range scaled by dataDimensions.
    vec3 frontPos = texture(frontFaces, normTexCoords).xyz * dataDimensions;
    vec3 backPos  = texture(backFaces, normTexCoords).xyz * dataDimensions;

    // If the ray is degenerate (e.g. the ray does not hit the volume), skip processing.
    if (all(equal(frontPos, backPos)))
        return;

    // Compute the normalized ray direction and its length.
    vec3 rayDir = normalize(backPos - frontPos);
    float rayLength = length(backPos - frontPos);
    
    // Compute the conversion from world/sample positions to normalized atlas texture coordinates.
    // This equals: (invDataDimensions * invAtlasLayout)
    vec3 worldPosToDataCoords = invDataDimensions * invAtlasLayout;

    // Get the starting output offset (in floats) for this ray.
    int rayOutputOffset = int(startIndices[rayID]);

    // Compute the ray marching increment vector.
    vec3 increment = rayDir * stepSize;

    // Precompute the total number of samples along the ray.
    int totalSamples = int(ceil(rayLength / stepSize));

    // Each thread processes a subset of samples along the ray.
    // For thread with id sampleThread, we loop starting at that index and then stride by the local size.
    for (int sampleIndex = int(sampleThread); sampleIndex < totalSamples; sampleIndex += int(gl_WorkGroupSize.y))
    {
        // Compute the sample position along the ray.	
        vec3 samplePos = frontPos + float(sampleIndex) * increment;

        // Convert the sample position into normalized atlas texture coordinates.
        vec3 volTexCoord = samplePos * worldPosToDataCoords;
        
        // Compute the output buffer offset for this sample.
        int sampleOutputOffset = (rayOutputOffset + sampleIndex) * voxelDimensions;

        // Loop over each brick needed (bricksNeeded tells how many bricks produce the full voxel data).
        int channelsWritten = 0;
        int bx = 0, by = 0, bz = 0;
        for (int b = 0; b < bricksNeeded; b++)
        {
            // Compute the brick offset in normalized atlas space.
            // We multiply the current brick index (bx,by,bz) by the reciprocal of atlasLayout.
            vec3 brickOffset = vec3(bx, by, bz) * invAtlasLayout;
            // The final texture coordinate for this brick is the offset plus the base sample coordinate.
            vec3 brickTexCoord = brickOffset + volTexCoord;
            
            // Sample the brick from the volume atlas.
            vec4 brickSample = texture(volumeData, brickTexCoord);
            
            // We check for each channel if it needs to be written to the output buffer 
            // We do this since the amount of dimensions is not always a multiple of 4
            for (int chan = 0; chan < 4; chan++)
            {
                if (channelsWritten >= voxelDimensions)
                    break;
                int outIndex = sampleOutputOffset + channelsWritten;
                if (chan == 0)
                    data[outIndex] = brickSample.r;
                else if (chan == 1)
                    data[outIndex] = brickSample.g;
                else if (chan == 2)
                    data[outIndex] = brickSample.b;
                else if (chan == 3)
                    data[outIndex] = brickSample.a;
                channelsWritten++;
            }
            
            // Update brick counters in x-first order.
            bx++;
            if (bx > int(atlasLayout.x))
            {
                bx = 0;
                by++;
                if (by > int(atlasLayout.y))
                {
                    by = 0;
                    bz++;
                }
            }
        }
    }
}